---
phase: 17-three-layer-soul-schema
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/20260215100001_soul_rpcs.sql
  - examples/supabase-schema-v2.sql
autonomous: true

must_haves:
  truths:
    - "get_current_soul() RPC returns the latest soul version's 3 layers"
    - "save_soul_version() RPC inserts a new soul version with auto-incremented version number"
    - "get_soul_history() RPC returns recent soul versions ordered by version DESC"
    - "save_milestone_moment() RPC inserts a milestone with emotional weight and lesson"
    - "get_milestone_moments() RPC returns milestones ordered by recency"
  artifacts:
    - path: "supabase/migrations/20260215100001_soul_rpcs.sql"
      provides: "5 RPCs for soul and milestone CRUD operations"
      contains: "CREATE OR REPLACE FUNCTION get_current_soul"
    - path: "examples/supabase-schema-v2.sql"
      provides: "Reference schema with all 5 new RPCs"
      contains: "get_current_soul"
  key_links:
    - from: "get_current_soul()"
      to: "soul_versions"
      via: "SELECT with ORDER BY version DESC LIMIT 1"
      pattern: "FROM soul_versions.*ORDER BY.*version DESC.*LIMIT 1"
    - from: "save_soul_version()"
      to: "soul_versions"
      via: "INSERT with auto-increment version from MAX(version)+1"
      pattern: "INSERT INTO soul_versions"
---

<objective>
Create Supabase RPCs for soul version and milestone moment CRUD operations.

Purpose: These RPCs are the API that Phase 18 (prompt integration) and Phase 19 (daily evolution engine) will call from relay.ts. Keeping logic in PostgreSQL functions follows the established pattern (get_facts, get_active_goals, match_memory).
Output: Migration SQL with 5 RPCs + updated reference schema
</objective>

<execution_context>
@/Users/roviana/.claude/get-shit-done/workflows/execute-plan.md
@/Users/roviana/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@examples/supabase-schema-v2.sql
@supabase/migrations/20260213100000_typed_memory_schema.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create RPCs for soul and milestone operations</name>
  <files>supabase/migrations/20260215100001_soul_rpcs.sql</files>
  <action>
Create a migration file with 5 RPCs following the established pattern (see get_facts(), get_active_goals() in typed_memory_schema.sql for style).

**1. get_current_soul()** — Returns the latest soul version (highest version number).
```sql
CREATE OR REPLACE FUNCTION get_current_soul()
RETURNS TABLE (
  id UUID,
  version INTEGER,
  core_identity TEXT,
  active_values TEXT,
  recent_growth TEXT,
  reflection_notes TEXT,
  token_count INTEGER,
  created_at TIMESTAMPTZ
) AS $$
BEGIN
  RETURN QUERY
  SELECT sv.id, sv.version, sv.core_identity, sv.active_values,
         sv.recent_growth, sv.reflection_notes, sv.token_count, sv.created_at
  FROM soul_versions sv
  ORDER BY sv.version DESC
  LIMIT 1;
END;
$$ LANGUAGE plpgsql;
```

**2. save_soul_version(p_core_identity, p_active_values, p_recent_growth, p_reflection_notes, p_token_count)** — Inserts a new version with auto-incremented version number.
```sql
CREATE OR REPLACE FUNCTION save_soul_version(
  p_core_identity TEXT,
  p_active_values TEXT,
  p_recent_growth TEXT,
  p_reflection_notes TEXT DEFAULT NULL,
  p_token_count INTEGER DEFAULT 0
)
RETURNS INTEGER AS $$
DECLARE
  v_next_version INTEGER;
BEGIN
  SELECT COALESCE(MAX(version), -1) + 1 INTO v_next_version FROM soul_versions;

  INSERT INTO soul_versions (version, core_identity, active_values, recent_growth, reflection_notes, token_count)
  VALUES (v_next_version, p_core_identity, p_active_values, p_recent_growth, p_reflection_notes, p_token_count);

  RETURN v_next_version;
END;
$$ LANGUAGE plpgsql;
```

**3. get_soul_history(p_limit)** — Returns recent soul versions for evolution context.
```sql
CREATE OR REPLACE FUNCTION get_soul_history(
  p_limit INTEGER DEFAULT 7
)
RETURNS TABLE (
  id UUID,
  version INTEGER,
  core_identity TEXT,
  active_values TEXT,
  recent_growth TEXT,
  token_count INTEGER,
  created_at TIMESTAMPTZ
) AS $$
BEGIN
  RETURN QUERY
  SELECT sv.id, sv.version, sv.core_identity, sv.active_values,
         sv.recent_growth, sv.token_count, sv.created_at
  FROM soul_versions sv
  ORDER BY sv.version DESC
  LIMIT p_limit;
END;
$$ LANGUAGE plpgsql;
```
Note: reflection_notes excluded from history query (large text, not needed for evolution context).

**4. save_milestone_moment(p_event_description, p_emotional_weight, p_lesson_learned, p_source_thread_id)** — Inserts a milestone moment.
```sql
CREATE OR REPLACE FUNCTION save_milestone_moment(
  p_event_description TEXT,
  p_emotional_weight TEXT DEFAULT 'meaningful',
  p_lesson_learned TEXT DEFAULT '',
  p_source_thread_id UUID DEFAULT NULL
)
RETURNS UUID AS $$
DECLARE
  v_id UUID;
BEGIN
  INSERT INTO soul_milestones (event_description, emotional_weight, lesson_learned, source_thread_id)
  VALUES (p_event_description, p_emotional_weight, p_lesson_learned, p_source_thread_id)
  RETURNING id INTO v_id;

  RETURN v_id;
END;
$$ LANGUAGE plpgsql;
```

**5. get_milestone_moments(p_limit)** — Returns milestone moments for evolution context.
```sql
CREATE OR REPLACE FUNCTION get_milestone_moments(
  p_limit INTEGER DEFAULT 10
)
RETURNS TABLE (
  id UUID,
  event_description TEXT,
  emotional_weight TEXT,
  lesson_learned TEXT,
  created_at TIMESTAMPTZ
) AS $$
BEGIN
  RETURN QUERY
  SELECT sm.id, sm.event_description, sm.emotional_weight,
         sm.lesson_learned, sm.created_at
  FROM soul_milestones sm
  ORDER BY sm.created_at DESC
  LIMIT p_limit;
END;
$$ LANGUAGE plpgsql;
```

Use `DROP FUNCTION IF EXISTS` before each CREATE OR REPLACE to handle return type changes cleanly (same pattern as typed_memory_schema.sql). Add clear section comments for each RPC.
  </action>
  <verify>
Read the migration file and confirm:
1. All 5 functions defined with correct signatures and return types
2. get_current_soul returns latest version (ORDER BY version DESC LIMIT 1)
3. save_soul_version auto-increments version via MAX(version)+1
4. get_soul_history excludes reflection_notes, default limit 7
5. save_milestone_moment returns UUID of created row
6. get_milestone_moments ordered by created_at DESC, default limit 10
7. DROP FUNCTION IF EXISTS before each function definition
  </verify>
  <done>5 RPCs created: get_current_soul, save_soul_version, get_soul_history, save_milestone_moment, get_milestone_moments — all with correct signatures, return types, and idempotent definitions</done>
</task>

<task type="auto">
  <name>Task 2: Add RPCs to reference schema</name>
  <files>examples/supabase-schema-v2.sql</files>
  <action>
Add the 5 new RPCs to `examples/supabase-schema-v2.sql` in the HELPER FUNCTIONS section, after the existing `match_memory()` function.

Add a comment separator:
```sql
-- ============================================================
-- SOUL VERSION & MILESTONE RPCs (v1.4 Phase 17)
-- ============================================================
```

Then add all 5 functions (same definitions as the migration, but using CREATE OR REPLACE without the DROP IF EXISTS since this is the reference schema).

Do NOT modify any existing functions or sections. Append only.
  </action>
  <verify>
Read examples/supabase-schema-v2.sql and confirm:
1. All 5 RPCs present after existing helper functions
2. Section header comment exists
3. No existing functions modified
  </verify>
  <done>Reference schema includes all 5 new soul/milestone RPCs with section header, all existing content preserved</done>
</task>

</tasks>

<verification>
1. Migration file exists at `supabase/migrations/20260215100001_soul_rpcs.sql`
2. get_current_soul() returns 3 layers + metadata from latest version
3. save_soul_version() auto-increments version number and returns it
4. get_soul_history() returns recent versions without reflection_notes
5. save_milestone_moment() inserts and returns UUID
6. get_milestone_moments() returns by recency with default limit
7. Reference schema includes all 5 RPCs
</verification>

<success_criteria>
- All 5 RPCs defined with correct parameter types, return types, and query logic
- Auto-increment version logic uses COALESCE(MAX(version), -1) + 1 for safe first-run
- History queries have sensible defaults (7 versions, 10 milestones)
- Reference schema updated with all RPCs
</success_criteria>

<output>
After completion, create `.planning/phases/17-three-layer-soul-schema/17-02-SUMMARY.md`
</output>
