---
phase: 14-schema-migration-typed-memory
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/20260213_typed_memory_schema.sql
  - examples/supabase-schema-v2.sql
autonomous: true

must_haves:
  truths:
    - "global_memory table has type, deadline, completed_at, priority, and embedding columns"
    - "Existing memory rows are backfilled with type = 'fact'"
    - "get_facts() RPC returns only fact-type entries"
    - "get_active_goals() RPC returns only goal-type entries with no completed_at"
    - "match_memory() RPC performs vector similarity search and returns ranked results"
    - "vector and pg_net extensions are enabled"
    - "Reference schema file reflects all new columns, indexes, and RPCs"
  artifacts:
    - path: "supabase/migrations/20260213_typed_memory_schema.sql"
      provides: "Migration adding typed memory columns, RPCs, and extensions"
      contains: "ALTER TABLE global_memory"
    - path: "examples/supabase-schema-v2.sql"
      provides: "Updated reference schema with typed memory"
      contains: "embedding VECTOR(1536)"
  key_links:
    - from: "supabase/migrations/20260213_typed_memory_schema.sql"
      to: "global_memory table"
      via: "ALTER TABLE ADD COLUMN"
      pattern: "ALTER TABLE global_memory ADD COLUMN"
    - from: "get_facts() RPC"
      to: "global_memory table"
      via: "SELECT WHERE type = 'fact'"
      pattern: "type = 'fact'"
    - from: "get_active_goals() RPC"
      to: "global_memory table"
      via: "SELECT WHERE type = 'goal' AND completed_at IS NULL"
      pattern: "type = 'goal'"
    - from: "match_memory() RPC"
      to: "global_memory.embedding column"
      via: "pgvector <=> operator for cosine distance"
      pattern: "embedding <=> query_embedding"
---

<objective>
Create the Supabase migration that evolves `global_memory` from a flat facts table into a typed memory system with support for facts, goals, preferences, and vector embeddings.

Purpose: This is the database foundation for v1.3 Smart Memory. Phase 15 (intent system) and Phase 16 (semantic search) both depend on these columns and RPCs existing.
Output: One migration SQL file and an updated reference schema.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@examples/supabase-schema-v2.sql
@supabase/migrations/20260210202924_schema_v2_threads_memory_soul.sql
@supabase/migrations/20260212_heartbeat_cron_schema.sql
@supabase/migrations/20260212_2_add_file_source.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create typed memory migration SQL</name>
  <files>supabase/migrations/20260213_typed_memory_schema.sql</files>
  <action>
Create migration file `supabase/migrations/20260213_typed_memory_schema.sql` with the following sections, in order:

**1. Enable extensions (idempotent):**
```sql
CREATE EXTENSION IF NOT EXISTS vector WITH SCHEMA extensions;
CREATE EXTENSION IF NOT EXISTS pg_net WITH SCHEMA extensions;
```
Note: Use `WITH SCHEMA extensions` which is the Supabase convention for extensions.

**2. Add columns to global_memory (all with defaults so existing rows are preserved):**
```sql
ALTER TABLE global_memory ADD COLUMN IF NOT EXISTS type TEXT NOT NULL DEFAULT 'fact'
  CHECK (type IN ('fact', 'goal', 'completed_goal', 'preference'));
ALTER TABLE global_memory ADD COLUMN IF NOT EXISTS deadline TIMESTAMPTZ;
ALTER TABLE global_memory ADD COLUMN IF NOT EXISTS completed_at TIMESTAMPTZ;
ALTER TABLE global_memory ADD COLUMN IF NOT EXISTS priority INTEGER DEFAULT 0;
ALTER TABLE global_memory ADD COLUMN IF NOT EXISTS embedding VECTOR(1536);
```

The `DEFAULT 'fact'` on the `type` column automatically backfills all existing rows as type `fact` -- no separate UPDATE needed since ADD COLUMN with DEFAULT is applied to existing rows in PostgreSQL 11+.

**3. Add indexes for the new columns:**
```sql
CREATE INDEX IF NOT EXISTS idx_global_memory_type ON global_memory(type);
CREATE INDEX IF NOT EXISTS idx_global_memory_type_active_goals
  ON global_memory(created_at DESC) WHERE type = 'goal' AND completed_at IS NULL;
CREATE INDEX IF NOT EXISTS idx_global_memory_embedding
  ON global_memory USING ivfflat (embedding vector_cosine_ops) WITH (lists = 100);
```

IMPORTANT: The ivfflat index requires at least some rows with embeddings to build. If the table is empty or has no embeddings yet, the index creation will still succeed but won't be usable until rows exist. This is fine -- Phase 16 will populate embeddings. If the table has very few rows (under 100), consider using HNSW instead of ivfflat as it works better for small datasets. Use this approach:

```sql
-- Use HNSW for small datasets (no minimum row requirement)
CREATE INDEX IF NOT EXISTS idx_global_memory_embedding
  ON global_memory USING hnsw (embedding vector_cosine_ops);
```

Choose HNSW over ivfflat -- it is better for small-to-medium datasets (which this will be), has no minimum row requirement, and provides better recall.

**4. Create get_facts() RPC:**
```sql
CREATE OR REPLACE FUNCTION get_facts()
RETURNS TABLE (
  id UUID,
  created_at TIMESTAMPTZ,
  content TEXT,
  source_thread_id UUID
) AS $$
BEGIN
  RETURN QUERY
  SELECT gm.id, gm.created_at, gm.content, gm.source_thread_id
  FROM global_memory gm
  WHERE gm.type = 'fact'
  ORDER BY gm.created_at DESC;
END;
$$ LANGUAGE plpgsql;
```

**5. Create get_active_goals() RPC:**
```sql
CREATE OR REPLACE FUNCTION get_active_goals()
RETURNS TABLE (
  id UUID,
  created_at TIMESTAMPTZ,
  content TEXT,
  deadline TIMESTAMPTZ,
  priority INTEGER,
  source_thread_id UUID
) AS $$
BEGIN
  RETURN QUERY
  SELECT gm.id, gm.created_at, gm.content, gm.deadline, gm.priority, gm.source_thread_id
  FROM global_memory gm
  WHERE gm.type = 'goal' AND gm.completed_at IS NULL
  ORDER BY gm.priority DESC NULLS LAST, gm.created_at DESC;
END;
$$ LANGUAGE plpgsql;
```

**6. Create match_memory() RPC for vector similarity search:**
```sql
CREATE OR REPLACE FUNCTION match_memory(
  query_embedding VECTOR(1536),
  match_threshold FLOAT DEFAULT 0.7,
  match_count INT DEFAULT 5
)
RETURNS TABLE (
  id UUID,
  content TEXT,
  type TEXT,
  similarity FLOAT
) AS $$
BEGIN
  RETURN QUERY
  SELECT
    gm.id,
    gm.content,
    gm.type,
    1 - (gm.embedding <=> query_embedding) AS similarity
  FROM global_memory gm
  WHERE gm.embedding IS NOT NULL
    AND 1 - (gm.embedding <=> query_embedding) > match_threshold
  ORDER BY gm.embedding <=> query_embedding
  LIMIT match_count;
END;
$$ LANGUAGE plpgsql;
```

**7. Add a header comment block** at the top of the file:
```sql
-- ============================================================
-- Schema v2.3: Typed Memory System
-- ============================================================
-- Evolves global_memory from flat facts to typed entries:
-- fact, goal, completed_goal, preference.
-- Adds vector embedding column for semantic search (Phase 16).
-- Creates helper RPCs: get_facts(), get_active_goals(), match_memory().
-- Part of Milestone v1.3: Smart Memory (Phase 14).
-- Non-destructive: preserves all existing data, backfills type='fact'.
```

Follow the exact pattern of previous migration files (header comments with `====` separators, section headers, inline comments explaining each column/constraint).
  </action>
  <verify>
Verify the SQL file:
1. File exists at `supabase/migrations/20260213_typed_memory_schema.sql`
2. Contains `CREATE EXTENSION IF NOT EXISTS vector`
3. Contains `CREATE EXTENSION IF NOT EXISTS pg_net`
4. Contains `ALTER TABLE global_memory ADD COLUMN IF NOT EXISTS type TEXT`
5. Contains `ALTER TABLE global_memory ADD COLUMN IF NOT EXISTS deadline TIMESTAMPTZ`
6. Contains `ALTER TABLE global_memory ADD COLUMN IF NOT EXISTS completed_at TIMESTAMPTZ`
7. Contains `ALTER TABLE global_memory ADD COLUMN IF NOT EXISTS priority INTEGER`
8. Contains `ALTER TABLE global_memory ADD COLUMN IF NOT EXISTS embedding VECTOR(1536)`
9. Contains `CREATE OR REPLACE FUNCTION get_facts()`
10. Contains `CREATE OR REPLACE FUNCTION get_active_goals()`
11. Contains `CREATE OR REPLACE FUNCTION match_memory(`
12. Contains CHECK constraint for type IN ('fact', 'goal', 'completed_goal', 'preference')
13. HNSW index on embedding column
14. All statements use IF NOT EXISTS or CREATE OR REPLACE (idempotent)
  </verify>
  <done>Migration SQL file creates all typed memory columns, indexes, and three RPCs. All statements are idempotent. Existing rows automatically get type='fact' via DEFAULT.</done>
</task>

<task type="auto">
  <name>Task 2: Update reference schema with typed memory</name>
  <files>examples/supabase-schema-v2.sql</files>
  <action>
Update `examples/supabase-schema-v2.sql` to reflect the new typed memory schema. This file serves as the canonical reference for the full database schema.

**Changes to the GLOBAL MEMORY section:**

1. Update the section comment from "Cross-thread learned facts" to "Cross-thread typed memory (facts, goals, preferences)"

2. Update the comment from referencing `[LEARN:]` and `[FORGET:]` to `[REMEMBER:]` and `[FORGET:]` (preparing for Phase 15 rename)

3. Replace the `global_memory` CREATE TABLE to include all new columns:
```sql
CREATE TABLE IF NOT EXISTS global_memory (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  content TEXT NOT NULL,                -- Concise entry (1-2 sentences max)
  type TEXT NOT NULL DEFAULT 'fact'     -- fact, goal, completed_goal, preference
    CHECK (type IN ('fact', 'goal', 'completed_goal', 'preference')),
  deadline TIMESTAMPTZ,                 -- Optional deadline for goals
  completed_at TIMESTAMPTZ,            -- When a goal was completed
  priority INTEGER DEFAULT 0,          -- Priority ordering (higher = more important)
  embedding VECTOR(1536),              -- OpenAI text-embedding-3-small vector
  source_thread_id UUID REFERENCES threads(id) ON DELETE SET NULL
);
```

4. Add the new indexes after the existing `idx_global_memory_created` index:
```sql
CREATE INDEX IF NOT EXISTS idx_global_memory_type ON global_memory(type);
CREATE INDEX IF NOT EXISTS idx_global_memory_type_active_goals
  ON global_memory(created_at DESC) WHERE type = 'goal' AND completed_at IS NULL;
CREATE INDEX IF NOT EXISTS idx_global_memory_embedding
  ON global_memory USING hnsw (embedding vector_cosine_ops);
```

5. Add the three new RPC functions (`get_facts()`, `get_active_goals()`, `match_memory()`) in the HELPER FUNCTIONS section, after the existing `get_active_soul()` function. Use the exact same function bodies as written in the migration file (Task 1).

6. Add extension enables at the very top of the file (before the first CREATE TABLE), in a new section:
```sql
-- ============================================================
-- EXTENSIONS
-- ============================================================
CREATE EXTENSION IF NOT EXISTS vector WITH SCHEMA extensions;
CREATE EXTENSION IF NOT EXISTS pg_net WITH SCHEMA extensions;
```

Keep all other existing content (threads, thread_messages, bot_soul, logs_v2, cron_jobs, heartbeat_config, RLS policies, existing helper functions) exactly as they are. This is an additive update only.
  </action>
  <verify>
Verify the updated reference schema:
1. File contains `VECTOR(1536)` in the global_memory CREATE TABLE
2. File contains `type TEXT NOT NULL DEFAULT 'fact'` in global_memory
3. File contains `deadline TIMESTAMPTZ` in global_memory
4. File contains `completed_at TIMESTAMPTZ` in global_memory
5. File contains `priority INTEGER DEFAULT 0` in global_memory
6. File contains `CREATE EXTENSION IF NOT EXISTS vector`
7. File contains functions: `get_facts()`, `get_active_goals()`, `match_memory()`
8. All existing tables (threads, thread_messages, bot_soul, logs_v2, cron_jobs, heartbeat_config) still present
9. All existing helper functions (get_or_create_thread, get_thread_messages, increment_thread_message_count, get_active_soul) still present
10. All existing RLS policies still present
  </verify>
  <done>Reference schema reflects the complete v2.3 database state including typed memory columns, new indexes, new RPCs, and enabled extensions. All existing content preserved.</done>
</task>

</tasks>

<verification>
Phase 14 verification checks:

1. **R1 (Typed Memory System):**
   - global_memory has `type` column with CHECK constraint for fact/goal/completed_goal/preference
   - global_memory has `deadline` (TIMESTAMPTZ), `completed_at` (TIMESTAMPTZ), `priority` (INTEGER), `embedding` (VECTOR(1536))
   - Existing rows get type='fact' via column DEFAULT

2. **R12 (Database Migration):**
   - Migration file exists at `supabase/migrations/20260213_typed_memory_schema.sql`
   - Enables `vector` and `pg_net` extensions
   - Creates `get_facts()`, `get_active_goals()`, `match_memory()` RPCs
   - All statements are idempotent (IF NOT EXISTS / CREATE OR REPLACE)

3. **NF3 (Backward Compatible):**
   - All ADD COLUMN use IF NOT EXISTS
   - type column has DEFAULT 'fact' (auto-backfills existing rows)
   - No DROP, DELETE, or destructive statements
   - Existing columns/indexes/policies untouched
</verification>

<success_criteria>
- Migration SQL file is syntactically valid and idempotent
- All 5 new columns added to global_memory (type, deadline, completed_at, priority, embedding)
- 3 RPCs created (get_facts, get_active_goals, match_memory)
- 2 extensions enabled (vector, pg_net)
- Reference schema updated to match
- Zero data loss risk (no destructive statements)
- Phase 15 can proceed to use these columns/RPCs in relay.ts
- Phase 16 can proceed to use match_memory() and embedding column
</success_criteria>

<output>
After completion, create `.planning/phases/14-schema-migration-typed-memory/14-01-SUMMARY.md`
</output>
