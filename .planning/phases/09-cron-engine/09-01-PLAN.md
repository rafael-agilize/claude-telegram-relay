---
phase: 09-cron-engine
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/relay.ts
  - package.json
  - CLAUDE.md
autonomous: true

must_haves:
  truths:
    - "A cron job with a 5-field expression (e.g. 0 7 * * *) fires at the correct time"
    - "A one-shot job (e.g. in 20m) fires once after the specified delay and is auto-disabled"
    - "An interval job (e.g. every 2h) fires repeatedly at fixed intervals"
    - "Each cron execution spawns a Claude call with the job prompt and target thread context"
    - "Cron results are delivered to the correct Telegram thread or DM fallback"
  artifacts:
    - path: "src/relay.ts"
      provides: "Cron engine: schedule parsing, tick loop, execution, delivery, lifecycle"
      contains: "cronTick"
    - path: "package.json"
      provides: "croner dependency"
      contains: "croner"
    - path: "CLAUDE.md"
      provides: "Updated documentation for cron engine behavior"
      contains: "cronTick"
  key_links:
    - from: "cronTick()"
      to: "getEnabledCronJobs()"
      via: "Supabase query for enabled jobs"
      pattern: "getEnabledCronJobs"
    - from: "cronTick()"
      to: "Croner/computeNextRun"
      via: "Schedule parsing to determine due jobs"
      pattern: "isJobDue|computeNextRun"
    - from: "executeCronJob()"
      to: "callClaude()"
      via: "Claude CLI call with job prompt and thread context"
      pattern: "callClaude.*job\\.prompt|callClaude.*prompt"
    - from: "executeCronJob()"
      to: "sendCronResultToTelegram()"
      via: "Delivery to target thread or DM"
      pattern: "sendCronResult"
    - from: "bot.start onStart"
      to: "startCronScheduler()"
      via: "Lifecycle integration on boot"
      pattern: "startCronScheduler"
    - from: "SIGINT/SIGTERM"
      to: "stopCronScheduler()"
      via: "Clean shutdown"
      pattern: "stopCronScheduler"
---

<objective>
Build the cron engine: a tick-based scheduler that polls enabled cron jobs from Supabase, determines which are due based on their schedule type (cron expression, interval, one-shot), executes them via Claude CLI calls, and delivers results to the correct Telegram thread.

Purpose: This is the core execution engine for scheduled tasks. Without it, cron jobs stored in the database have no way to run.

Output: Working cron scheduler integrated into relay.ts lifecycle with schedule parsing, execution, and delivery for all three schedule types.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-heartbeat-core/07-heartbeat-core-SUMMARY.md
@src/relay.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install croner and add cron schedule parsing + tick loop + execution + delivery</name>
  <files>src/relay.ts, package.json</files>
  <action>
**Step 1: Install croner library**

Run `bun add croner` to add the cron expression parsing library.

**Step 2: Add cron engine code to relay.ts**

Add `import { Cron } from "croner"` at the top with other imports.

Add the following functions AFTER the existing `disableCronJob()` function (around line 543) and BEFORE the heartbeat section. Use a new section comment: `// ============================================================ // CRON SCHEDULER ENGINE (Phase 9) // ============================================================`

**Module-level state:**
```typescript
let cronTimer: Timer | null = null;
let cronRunning = false;
const CRON_TICK_INTERVAL_MS = 60 * 1000; // Check every 60 seconds
```

**Function specifications (complete implementations provided below):**

**Function: `computeNextRun(job: CronJob): string | null`**
Computes the next run timestamp based on schedule_type:
- `cron`: Use `new Cron(job.schedule).nextRun()?.toISOString()` — croner parses 5-field expressions natively. If schedule is invalid, log error and return null.
- `interval`: Parse schedule string like "every 2h", "every 30m", "every 1h30m". Use regex: `/every\s+(?:(\d+)h)?(?:(\d+)m)?/i`. Compute next_run_at as `last_run_at + interval` (or `now + interval` if never ran). Return ISO string.
- `once`: Parse schedule string like "in 20m", "in 1h", "in 2h30m". Use regex: `/in\s+(?:(\d+)h)?(?:(\d+)m)?/i`. Compute next_run_at as `created_at + delay`. Return ISO string. If the computed time is in the past and job has never run, it means the job is due NOW — return current time ISO.

```typescript
function computeNextRun(job: CronJob): string | null {
  const now = new Date();

  if (job.schedule_type === "cron") {
    try {
      const cronInstance = new Cron(job.schedule);
      const nextRun = cronInstance.nextRun();
      return nextRun ? nextRun.toISOString() : null;
    } catch (err) {
      console.error(`[Cron] Invalid cron expression for job ${job.id} (${job.name}): ${job.schedule}`, err);
      return null;
    }
  }

  if (job.schedule_type === "interval") {
    const match = job.schedule.match(/every\s+(?:(\d+)h)?(?:(\d+)m)?/i);
    if (!match) {
      console.error(`[Cron] Invalid interval format for job ${job.id}: ${job.schedule}`);
      return null;
    }
    const hours = parseInt(match[1] || "0", 10);
    const minutes = parseInt(match[2] || "0", 10);
    const intervalMs = (hours * 60 + minutes) * 60 * 1000;

    if (intervalMs === 0) {
      console.error(`[Cron] Zero interval for job ${job.id}: ${job.schedule}`);
      return null;
    }

    const baseTime = job.last_run_at ? new Date(job.last_run_at) : now;
    const nextRun = new Date(baseTime.getTime() + intervalMs);
    return nextRun.toISOString();
  }

  if (job.schedule_type === "once") {
    const match = job.schedule.match(/in\s+(?:(\d+)h)?(?:(\d+)m)?/i);
    if (!match) {
      console.error(`[Cron] Invalid once format for job ${job.id}: ${job.schedule}`);
      return null;
    }
    const hours = parseInt(match[1] || "0", 10);
    const minutes = parseInt(match[2] || "0", 10);
    const delayMs = (hours * 60 + minutes) * 60 * 1000;

    if (delayMs === 0) {
      console.error(`[Cron] Zero delay for one-shot job ${job.id}: ${job.schedule}`);
      return null;
    }

    const scheduledTime = new Date(new Date(job.created_at).getTime() + delayMs);

    // If scheduled time is in the past and job has never run, it's due now
    if (scheduledTime < now && !job.last_run_at) {
      return now.toISOString();
    }

    return scheduledTime.toISOString();
  }

  return null;
}
```

**Function: `isJobDue(job: CronJob): boolean`**
Returns true if the job should execute now:
- If `job.next_run_at` is set and `new Date(job.next_run_at) <= new Date()`, return true.
- If `job.next_run_at` is null (never computed), compute it via `computeNextRun()`, and if the result is `<= now`, return true. (This handles newly created jobs.)

```typescript
function isJobDue(job: CronJob): boolean {
  const now = new Date();

  if (job.next_run_at) {
    return new Date(job.next_run_at) <= now;
  }

  // First time: compute next_run_at
  const nextRun = computeNextRun(job);
  if (!nextRun) return false;

  return new Date(nextRun) <= now;
}
```

**Function: `getThreadInfoForCronJob(job: CronJob): Promise<ThreadInfo | undefined>`**
Resolves a cron job's `target_thread_id` (UUID from threads table) into a ThreadInfo for Claude context:
- If `job.target_thread_id` is null, return undefined (standalone call, no thread context).
- Query Supabase: `supabase.from("threads").select("*").eq("id", job.target_thread_id).single()`.
- If found, construct a ThreadInfo object: `{ dbId: data.id, chatId: data.telegram_chat_id, threadId: data.telegram_thread_id, title: data.title, sessionId: data.claude_session_id, summary: data.summary || "", messageCount: data.message_count || 0 }`.
- If not found, return undefined (thread was deleted).

```typescript
async function getThreadInfoForCronJob(job: CronJob): Promise<ThreadInfo | undefined> {
  if (!job.target_thread_id) return undefined;

  const { data, error } = await supabase
    .from("threads")
    .select("*")
    .eq("id", job.target_thread_id)
    .single();

  if (error || !data) {
    console.error(`[Cron] Target thread not found for job ${job.id}:`, error);
    return undefined;
  }

  return {
    dbId: data.id,
    chatId: data.telegram_chat_id,
    threadId: data.telegram_thread_id,
    title: data.title,
    sessionId: data.claude_session_id,
    summary: data.summary || "",
    messageCount: data.message_count || 0,
  };
}
```

**Function: `sendCronResultToTelegram(message: string, job: CronJob, threadInfo?: ThreadInfo): Promise<void>`**
Delivers cron execution result to the correct Telegram destination:
- Determine chatId and threadId:
  - If `threadInfo` exists: use `threadInfo.chatId` and `threadInfo.threadId`.
  - Otherwise: use `parseInt(ALLOWED_USER_ID)` (DM fallback), no threadId.
- Convert markdown to HTML using existing `markdownToTelegramHtml()`.
- Send via `bot.api.sendMessage(chatId, html, { parse_mode: "HTML", message_thread_id: threadId })`.
- On HTML parse error: retry without parse_mode (strip tags).
- Handle chunking for long messages (same pattern as `sendHeartbeatToTelegram()` with 4000 char limit).
- Prefix the message with a brief header: `<b>[Cron: ${job.name}]</b>\n\n` so the user knows which job produced the output.

```typescript
async function sendCronResultToTelegram(
  message: string,
  job: CronJob,
  threadInfo?: ThreadInfo
): Promise<void> {
  const chatId = threadInfo ? threadInfo.chatId : parseInt(ALLOWED_USER_ID);
  const threadId = threadInfo?.threadId;

  const prefix = `<b>[Cron: ${job.name}]</b>\n\n`;
  const fullMessage = prefix + message;
  const html = markdownToTelegramHtml(fullMessage);

  const chunks: string[] = [];
  if (html.length <= 4000) {
    chunks.push(html);
  } else {
    // Split into chunks
    const lines = html.split("\n");
    let currentChunk = "";
    for (const line of lines) {
      if (currentChunk.length + line.length + 1 > 4000) {
        chunks.push(currentChunk);
        currentChunk = line;
      } else {
        currentChunk += (currentChunk ? "\n" : "") + line;
      }
    }
    if (currentChunk) chunks.push(currentChunk);
  }

  for (const chunk of chunks) {
    try {
      await bot.api.sendMessage(chatId, chunk, {
        parse_mode: "HTML",
        message_thread_id: threadId,
      });
    } catch (err: any) {
      if (err.description?.includes("can't parse entities")) {
        const stripped = chunk.replace(/<[^>]*>/g, "");
        await bot.api.sendMessage(chatId, stripped, { message_thread_id: threadId });
      } else {
        console.error("[Cron] Failed to send message:", err);
      }
    }
  }
}
```

**Function: `async function executeCronJob(job: CronJob): Promise<void>`**
Executes a single cron job:
1. Log event: `await logEventV2("cron_executed", "Cron job fired: " + job.name, { job_id: job.id, job_name: job.name, schedule: job.schedule, schedule_type: job.schedule_type })`.
2. Resolve thread: `const threadInfo = await getThreadInfoForCronJob(job)`.
3. Build prompt: Include soul + global memory + the job's prompt + current time.
4. Call Claude: `const { text, sessionId } = await callClaude(prompt, threadInfo)`.
5. If threadInfo and sessionId, update thread session: `await updateThreadSession(threadInfo.dbId, sessionId)`.
6. If response is empty or error, log `cron_error` and return.
7. Process intents: `const cleanResponse = await processIntents(text, threadInfo?.dbId)`.
8. Strip voice tags: `cleanResponse.replace(/\[VOICE_REPLY\]/gi, "").trim()`.
9. Deliver: `await sendCronResultToTelegram(finalMessage, job, threadInfo)`.
10. Compute next run: `const nextRun = computeNextRun(job)`.
11. Update last_run_at: `await updateCronJobLastRun(job.id, nextRun || undefined)`.
12. For one-shot jobs: `if (job.schedule_type === "once") { await disableCronJob(job.id); }`.
13. Log success: `await logEventV2("cron_delivered", "Cron result delivered: " + job.name, { job_id: job.id, message_length: finalMessage.length })`.

```typescript
async function executeCronJob(job: CronJob): Promise<void> {
  await logEventV2("cron_executed", `Cron job fired: ${job.name}`, {
    job_id: job.id,
    job_name: job.name,
    schedule: job.schedule,
    schedule_type: job.schedule_type,
  });

  const threadInfo = await getThreadInfoForCronJob(job);

  // Build prompt
  const soul = await getActiveSoul();
  const globalMemory = await getGlobalMemory();

  const timeZone = "America/Sao_Paulo";
  const timeString = new Date().toLocaleString("en-US", {
    timeZone,
    dateStyle: "full",
    timeStyle: "long",
  });

  let prompt = soul + `\n\nCurrent time: ${timeString}\n\n`;

  if (globalMemory.length > 0) {
    prompt += "THINGS I KNOW ABOUT THE USER:\n";
    prompt += globalMemory.map((m) => `- ${m}`).join("\n");
    prompt += "\n\n";
  }

  if (threadInfo && threadInfo.summary) {
    prompt += `THREAD CONTEXT:\n${threadInfo.summary}\n\n`;
  }

  prompt += `SCHEDULED TASK:\n${job.prompt}`;

  // Call Claude
  let text = "";
  let sessionId = threadInfo?.sessionId;

  try {
    const result = await callClaude(prompt, threadInfo);
    text = result.text;
    sessionId = result.sessionId;
  } catch (err: any) {
    await logEventV2("cron_error", `Cron execution failed for ${job.name}: ${err.message}`, {
      job_id: job.id,
      error: err.message,
    });
    return;
  }

  if (!text || text.trim() === "") {
    await logEventV2("cron_error", `Cron job ${job.name} returned empty response`, {
      job_id: job.id,
    });
    return;
  }

  // Update session if needed
  if (threadInfo && sessionId && sessionId !== threadInfo.sessionId) {
    await updateThreadSession(threadInfo.dbId, sessionId);
  }

  // Process intents
  const cleanResponse = await processIntents(text, threadInfo?.dbId);

  // Strip voice tags
  const finalMessage = cleanResponse.replace(/\[VOICE_REPLY\]/gi, "").trim();

  // Deliver
  await sendCronResultToTelegram(finalMessage, job, threadInfo);

  // Update next_run_at
  const nextRun = computeNextRun(job);
  await updateCronJobLastRun(job.id, nextRun || undefined);

  // Auto-disable one-shot jobs
  if (job.schedule_type === "once") {
    await disableCronJob(job.id);
  }

  await logEventV2("cron_delivered", `Cron result delivered: ${job.name}`, {
    job_id: job.id,
    message_length: finalMessage.length,
  });
}
```

**Function: `async function cronTick(): Promise<void>`**
The main tick loop (runs every 60 seconds). Complete implementation:

```typescript
async function cronTick(): Promise<void> {
  // Guard against overlapping ticks
  if (cronRunning) {
    console.log("[Cron] Tick skipped (previous tick still running)");
    return;
  }

  cronRunning = true;

  try {
    const jobs = await getEnabledCronJobs();

    if (jobs.length === 0) {
      return;
    }

    console.log(`[Cron] Tick: checking ${jobs.length} enabled job(s)`);

    for (const job of jobs) {
      try {
        // Ensure next_run_at is computed
        if (!job.next_run_at) {
          const nextRun = computeNextRun(job);
          if (nextRun) {
            await updateCronJobLastRun(job.id, nextRun);
            job.next_run_at = nextRun; // Update in-memory for this tick
          } else {
            console.error(`[Cron] Could not compute next_run_at for job ${job.id}`);
            continue;
          }
        }

        // Check if due
        if (isJobDue(job)) {
          console.log(`[Cron] Executing due job: ${job.name} (${job.id})`);
          await executeCronJob(job);
        }
      } catch (err: any) {
        await logEventV2("cron_error", `Cron tick error for job ${job.name}: ${err.message}`, {
          job_id: job.id,
          error: err.message,
          stack: err.stack,
        });
        console.error(`[Cron] Error executing job ${job.id}:`, err);
      }
    }
  } finally {
    cronRunning = false;
  }
}
```

**Function: `startCronScheduler(): void`**
```typescript
function startCronScheduler(): void {
  if (cronTimer) clearInterval(cronTimer);
  cronTimer = setInterval(cronTick, CRON_TICK_INTERVAL_MS);
  console.log("Cron scheduler: started (checking every 60s)");
}
```

**Function: `stopCronScheduler(): void`**
```typescript
function stopCronScheduler(): void {
  if (cronTimer) {
    clearInterval(cronTimer);
    cronTimer = null;
    console.log("Cron scheduler: stopped");
  }
}
```

**Step 3: Integrate into lifecycle**

1. In the `bot.start({ onStart: ... })` callback (around line 1756), after the heartbeat start block, add:
```typescript
// Start cron scheduler
startCronScheduler();
```

2. In both SIGINT and SIGTERM handlers (around lines 1059-1069), add `stopCronScheduler()` right after `stopHeartbeat()`:
```typescript
process.on("SIGINT", async () => {
  stopHeartbeat();
  stopCronScheduler();
  ...
});
process.on("SIGTERM", async () => {
  stopHeartbeat();
  stopCronScheduler();
  ...
});
```

**Important implementation notes:**
- croner library is used ONLY for `schedule_type: 'cron'`. Interval and one-shot parsing is manual regex.
- Interval regex: `/every\s+(?:(\d+)h)?(?:(\d+)m)?/i` matches "every 2h", "every 30m", "every 1h30m"
- Once regex: `/in\s+(?:(\d+)h)?(?:(\d+)m)?/i` matches "in 20m", "in 1h", "in 2h30m"
- The cronTick interval is 60 seconds (independent of heartbeat interval). This means jobs are accurate to within ~1 minute.
- Jobs execute sequentially within a single tick to prevent concurrent Claude CLI calls from the cron system.
- The `cronRunning` guard prevents tick N+1 from starting while tick N is still executing long-running jobs.
- Intent processing ([LEARN:], [FORGET:]) works in cron context, same as heartbeat.
- One-shot jobs are disabled AFTER successful execution, not before (so they retry on failure).
  </action>
  <verify>
1. `bun run build` or `bun run start` does not crash (syntax check)
2. `import { Cron } from "croner"` resolves (croner is in package.json and node_modules)
3. grep for `cronTick` in relay.ts returns the function
4. grep for `startCronScheduler` in relay.ts returns the function AND its call in onStart
5. grep for `stopCronScheduler` in relay.ts returns the function AND its calls in SIGINT/SIGTERM
6. grep for `executeCronJob` in relay.ts returns the function
7. grep for `sendCronResultToTelegram` in relay.ts returns the function
8. grep for `computeNextRun` in relay.ts returns the function with all 3 schedule_type cases
9. grep for `isJobDue` in relay.ts returns the function
  </verify>
  <done>
All three schedule types (cron, interval, once) are parsed and their next_run_at computed. The tick loop polls every 60s, identifies due jobs, executes them via Claude CLI (with thread context if target_thread_id is set), delivers results to the correct Telegram thread or DM, updates last_run_at/next_run_at, and auto-disables one-shot jobs. Cron scheduler starts on boot and stops on shutdown. Complete TypeScript implementations are provided for all 8 functions with explicit regex patterns for interval and once parsing.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update CLAUDE.md with cron engine documentation</name>
  <files>CLAUDE.md</files>
  <action>
Update CLAUDE.md to document the cron engine behavior added in Task 1.

**Change 1:** In the "Architecture" section, find the `**Heartbeat & cron events**` bullet and update to include new cron event types:

Find:
```
- **Heartbeat & cron events** — Logged to `logs_v2` with event types: `heartbeat_tick`, `heartbeat_ok`, `heartbeat_delivered`, `heartbeat_dedup`, `heartbeat_skip`, `heartbeat_error`, `cron_executed`, `cron_error`, `bot_stopping`
```

Replace with:
```
- **Heartbeat & cron events** — Logged to `logs_v2` with event types: `heartbeat_tick`, `heartbeat_ok`, `heartbeat_delivered`, `heartbeat_dedup`, `heartbeat_skip`, `heartbeat_error`, `cron_executed`, `cron_delivered`, `cron_error`, `bot_stopping`
```

**Change 2:** In the "Architecture" section, after the `**Heartbeat timer**` bullet, add a new bullet for the cron scheduler:

```
- **Cron scheduler** — `cronTick()` fires every 60s, polls `cron_jobs` table for enabled jobs, checks `next_run_at` to determine due jobs. Supports three schedule types: `cron` (5-field via croner library), `interval` (e.g. "every 2h"), `once` (e.g. "in 20m"). Each execution spawns a Claude call with job prompt and thread context, delivers result to target thread or DM. One-shot jobs auto-disable after execution. Starts on boot via `onStart`, stops on SIGINT/SIGTERM.
```

**Change 3:** In the "Dependencies" section, add croner:

After the `**ffmpeg**` line, add:
```
- **croner** ^9+ — Cron expression parser for 5-field cron schedules with timezone support
```

**Change 4:** In the "Key sections in relay.ts" area, add a bullet for cron:

After the heartbeat-related bullets, add:
```
- **Cron scheduler engine** — `cronTick()`, `executeCronJob()`, `sendCronResultToTelegram()`, `computeNextRun()`, `isJobDue()`, `getThreadInfoForCronJob()`, `startCronScheduler()`, `stopCronScheduler()`
```
  </action>
  <verify>
1. grep for "Cron scheduler" in CLAUDE.md returns the new architecture bullet
2. grep for "croner" in CLAUDE.md returns the new dependency entry
3. grep for "cron_delivered" in CLAUDE.md confirms updated event types
4. grep for "cronTick" in CLAUDE.md returns the cron scheduler engine bullet
  </verify>
  <done>
CLAUDE.md accurately documents the cron engine: schedule types, tick interval, execution flow, delivery routing, lifecycle integration, croner dependency, and all cron event types.
  </done>
</task>

</tasks>

<verification>
1. `bun run start` boots without errors, prints "Cron scheduler: started (checking every 60s)" in console
2. All functions exist: cronTick, executeCronJob, sendCronResultToTelegram, computeNextRun, isJobDue, getThreadInfoForCronJob, startCronScheduler, stopCronScheduler
3. croner is listed in package.json dependencies
4. Lifecycle: startCronScheduler() is called in onStart, stopCronScheduler() is called in both SIGINT and SIGTERM handlers
5. CLAUDE.md documents cron engine behavior, croner dependency, and event types
</verification>

<success_criteria>
- Cron jobs with 5-field expressions execute at correct times (within 60s accuracy)
- One-shot timer jobs fire once and auto-disable
- Interval jobs fire repeatedly at fixed intervals
- Each execution spawns Claude call with appropriate thread context
- Results delivered to correct Telegram thread or DM fallback
- Cron scheduler starts on boot and stops cleanly on shutdown
- No interference with heartbeat system
</success_criteria>

<output>
After completion, create `.planning/phases/09-cron-engine/09-cron-engine-SUMMARY.md`
</output>
