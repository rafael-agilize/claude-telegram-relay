---
phase: 19-daily-evolution-engine
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [src/relay.ts]
autonomous: true

must_haves:
  truths:
    - "getLast24hMessages() returns messages from ALL threads in the last 24 hours"
    - "getSoulHistory() returns recent soul versions from Supabase RPC"
    - "Evolution cron job is created on bot startup with configurable schedule (default midnight)"
    - "Evolution tick only fires at configured hour (EVOLUTION_HOUR) and skips if already running"
  artifacts:
    - path: "src/relay.ts"
      provides: "getLast24hMessages(), getSoulHistory(), evolution cron infrastructure"
      contains: "getLast24hMessages"
  key_links:
    - from: "getLast24hMessages()"
      to: "supabase.from('thread_messages')"
      via: "date-filtered cross-thread query"
      pattern: "thread_messages.*gte.*24h"
    - from: "getSoulHistory()"
      to: "supabase.rpc('get_soul_history')"
      via: "RPC call"
      pattern: "rpc.*get_soul_history"
---

<objective>
Add data-gathering helpers and cron infrastructure for daily soul evolution.

Purpose: Phase 19 needs two foundations before the reflection logic: (1) functions to pull 24h interaction data and soul version history from Supabase, and (2) a cron-like timer that triggers evolution at a configurable time (default midnight). This plan builds both.

Output: `getLast24hMessages()`, `getSoulHistory()`, evolution timer with schedule config, guard against overlapping runs.
</objective>

<execution_context>
@/Users/roviana/.claude/get-shit-done/workflows/execute-plan.md
@/Users/roviana/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-prompt-integration/18-01-SUMMARY.md
@src/relay.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add getLast24hMessages() and getSoulHistory() data helpers</name>
  <files>src/relay.ts</files>
  <action>
Add two new async functions near the existing soul helpers (around line 513, after getCurrentSoul):

1. `async function getLast24hMessages(): Promise<Array<{ role: string; content: string; thread_name: string; created_at: string }>>` — Queries `thread_messages` table for ALL rows where `created_at >= now() - 24h`. Order by `created_at ASC`. Use supabase-js `.gte('created_at', cutoffISO)` filter where cutoffISO is `new Date(Date.now() - 24*60*60*1000).toISOString()`. Select `role, content, created_at, thread_id` from thread_messages. Cap at 200 messages to avoid token explosion (`.limit(200)`). Return empty array on error (graceful fallback).

**Thread name mapping (two-step, no joins):**
   - Step 1: Fetch threads from `threads` table (`id, name`), build a `Map<string, string>` of thread_id → thread_name.
   - Step 2: Fetch messages with the date filter above (selecting `role, content, created_at, thread_id`).
   - Step 3: Map each message's `thread_id` to thread name using the threads map. Use `"Unknown"` as fallback if thread not found.

2. `async function getSoulHistory(limit: number = 3): Promise<SoulVersion[]>` — Calls `supabase.rpc('get_soul_history', { p_limit: limit })`. Returns array of SoulVersion objects. Default limit 3 (not 7 — we only need recent context for reflection, not a full week). Return empty array on error.

**SoulVersion interface:** First grep for an existing `SoulVersion` type/interface in relay.ts. If it exists, reuse it. If it does NOT exist, define it near the other Supabase types: `interface SoulVersion { version: number; core_identity: string; active_values: string; recent_growth: string; reflection_notes: string; token_count: number; created_at: string; }`. This interface is also used by Plan 02 (buildEvolutionPrompt, parseEvolutionResponse).

Both functions follow the existing error-handling pattern: try/catch, console.error, return empty on failure.
  </action>
  <verify>
Grep for `getLast24hMessages` and `getSoulHistory` in relay.ts to confirm both exist. Verify they follow the graceful fallback pattern (return empty on error).
  </verify>
  <done>
Both helpers exist, query correct tables, handle errors gracefully, and return typed arrays.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add daily evolution timer with configurable schedule</name>
  <files>src/relay.ts</files>
  <action>
Add evolution timer infrastructure following the same pattern as heartbeat timer (startHeartbeat/stopHeartbeat/heartbeatTick):

1. Add module-level variables near the heartbeat ones (around line 1250):
   - `let evolutionTimer: ReturnType<typeof setInterval> | null = null;`
   - `let evolutionRunning = false;`
   - `const EVOLUTION_HOUR = parseInt(process.env.EVOLUTION_HOUR || "0");` (0 = midnight, configurable)
   - `const EVOLUTION_TIMEZONE = process.env.EVOLUTION_TIMEZONE || "America/Sao_Paulo";`

2. Add `async function evolutionTick(): Promise<void>` — Guard against overlapping runs (`if (evolutionRunning) return; evolutionRunning = true;` with finally block to reset). Check if current hour matches EVOLUTION_HOUR in the configured timezone (use `new Date().toLocaleString('en-US', { timeZone: EVOLUTION_TIMEZONE, hour: 'numeric', hour12: false })` to get current hour). **Do NOT check active hours** — evolution deliberately runs at midnight which is outside normal active hours. If hour doesn't match, return silently (the timer fires every 30min to check, but only triggers at the right hour). Add a daily dedup: store `lastEvolutionDate` (string like "2026-02-15") and skip if already ran today. Log `evolution_tick` event. The actual reflection logic will be added in Plan 02 — for now, just log "Evolution: tick triggered, ready for reflection" and return.

3. Add `function startEvolutionTimer(): void` — Sets `evolutionTimer = setInterval(evolutionTick, 30 * 60 * 1000)` (check every 30 minutes). Log start message.

4. Add `function stopEvolutionTimer(): void` — Clears interval, sets null, logs stop.

5. Wire into bot lifecycle: In the `onStart` handler (where startHeartbeat and startCronScheduler are called), add `startEvolutionTimer()`. In the SIGINT/SIGTERM handlers (where stopHeartbeat and stopCronScheduler are called), add `stopEvolutionTimer()`.

Pattern reference: Follow heartbeatTick/startHeartbeat/stopHeartbeat exactly for structure.
  </action>
  <verify>
Grep for `evolutionTick`, `startEvolutionTimer`, `stopEvolutionTimer` in relay.ts. Verify they're wired into onStart and signal handlers. Check that EVOLUTION_HOUR and EVOLUTION_TIMEZONE are declared.
  </verify>
  <done>
Evolution timer starts on bot boot, checks every 30 minutes, only triggers at configured hour, guards against overlapping runs, and stops cleanly on shutdown.
  </done>
</task>

</tasks>

<verification>
1. `grep -n "getLast24hMessages\|getSoulHistory\|evolutionTick\|startEvolutionTimer\|stopEvolutionTimer" src/relay.ts` — all 5 functions exist
2. `grep -n "EVOLUTION_HOUR\|EVOLUTION_TIMEZONE\|lastEvolutionDate" src/relay.ts` — config and dedup guard exist
3. `grep -n "startEvolutionTimer\|stopEvolutionTimer" src/relay.ts` — wired into lifecycle (onStart + signal handlers)
4. No syntax errors: `bun build src/relay.ts --no-bundle 2>&1 | head -5` or similar check
</verification>

<success_criteria>
- getLast24hMessages() queries thread_messages with 24h date filter across all threads
- getSoulHistory() calls get_soul_history RPC with configurable limit
- Evolution timer fires every 30 min, but only triggers reflection at configured hour
- Timer is started on bot boot and stopped on shutdown
- Daily dedup prevents multiple evolution runs per day
</success_criteria>

<output>
After completion, create `.planning/phases/19-daily-evolution-engine/19-01-SUMMARY.md`
</output>
