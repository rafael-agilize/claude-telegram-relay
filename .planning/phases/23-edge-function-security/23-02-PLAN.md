---
phase: 23-edge-function-security
plan: 02
type: execute
wave: 2
depends_on: ["23-01"]
files_modified:
  - supabase/functions/embed/index.ts
  - supabase/functions/search/index.ts
autonomous: true

must_haves:
  truths:
    - "Embed function fetches content from global_memory by row ID, ignoring any client-supplied content"
    - "Search function clamps match_count to maximum 20"
    - "Search function clamps match_threshold to minimum 0.5"
  artifacts:
    - path: "supabase/functions/embed/index.ts"
      provides: "DB-sourced content for embedding generation"
      contains: "global_memory"
    - path: "supabase/functions/search/index.ts"
      provides: "Clamped search parameters"
      contains: "Math.min"
  key_links:
    - from: "supabase/functions/embed/index.ts"
      to: "global_memory table"
      via: "SELECT by row ID to get trusted content"
      pattern: "from.*global_memory.*select.*eq.*id"
    - from: "supabase/functions/search/index.ts"
      to: "match_memory RPC"
      via: "Clamped parameters passed to RPC call"
      pattern: "Math\\.(min|max)"
---

<objective>
Harden input validation for both Edge Functions: embed fetches from DB instead of trusting client content, search clamps query parameters.

Purpose: Prevent callers from injecting arbitrary content for embedding (EDGE-02) and from requesting excessive or overly-broad search results (EDGE-03).
Output: Embed function is DB-sourced; search function enforces parameter bounds.
</objective>

<execution_context>
@/Users/roviana/.claude/get-shit-done/workflows/execute-plan.md
@/Users/roviana/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/23-edge-function-security/23-01-SUMMARY.md
@supabase/functions/embed/index.ts
@supabase/functions/search/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Embed function fetches content from database by row ID</name>
  <files>supabase/functions/embed/index.ts</files>
  <action>
Refactor the embed function so it NEVER uses client-supplied `content` for embedding generation. Instead, it receives only the row `id` and fetches the actual content from the `global_memory` table.

**Current flow:**
1. Receives `{ record: { id, content } }` from webhook or `{ id, content }` from direct call
2. Uses `record.content` directly in OpenAI embedding request

**New flow:**
1. Receives payload, extracts `id` from `payload.record?.id || payload.id`
2. If no `id`, return 400 with `{ "error": "Missing record ID" }`
3. Query `global_memory` table: `supabase.from("global_memory").select("id, content, embedding").eq("id", id).single()`
4. If row not found, return 404 with `{ "error": "Record not found" }`
5. If `row.embedding` already exists, return 200 with `{ "skipped": true }` (idempotency check, same as current)
6. If `row.content` is empty/null, return 400 with `{ "error": "Record has no content" }`
7. Use `row.content` (from DB) for OpenAI embedding generation
8. Update the row with the embedding (same as current)
9. Log with `row.content.substring(0, 50)` (same as current)

Key changes:
- Remove `record.content` usage from client payload entirely
- Only `id` is extracted from the client payload
- The `content` used for embedding comes exclusively from the database query
- Remove the old validation `if (!record.id || !record.content)` and replace with ID-only validation
- The embedding existence check now uses the DB-fetched row instead of `record.embedding` from the payload

This ensures a malicious caller cannot inject arbitrary text for embedding — the content is always the authoritative value from the database.
  </action>
  <verify>
Read embed/index.ts and confirm:
- No reference to `record.content` or `payload.content` used for embedding
- Database SELECT query fetches content by ID
- Content for OpenAI API comes from the DB query result
- 404 returned when row not found
- Idempotency check uses DB-fetched embedding field
  </verify>
  <done>Embed function fetches content exclusively from global_memory table by row ID. Client-supplied content is ignored.</done>
</task>

<task type="auto">
  <name>Task 2: Search function clamps match_count and match_threshold</name>
  <files>supabase/functions/search/index.ts</files>
  <action>
Add parameter clamping after extracting `match_count` and `match_threshold` from the request body.

**Current code (lines ~18-19):**
```typescript
const matchCount = body.match_count ?? 5;
const matchThreshold = body.match_threshold ?? 0.7;
```

**Replace with:**
```typescript
const rawMatchCount = body.match_count ?? 5;
const rawMatchThreshold = body.match_threshold ?? 0.7;

// EDGE-03: Clamp parameters to safe bounds
const matchCount = Math.min(Math.max(Math.round(rawMatchCount), 1), 20);
const matchThreshold = Math.max(Math.min(rawMatchThreshold, 1.0), 0.5);
```

Clamping rules:
- `match_count`: integer between 1 and 20 (round to nearest integer, floor at 1, cap at 20)
- `match_threshold`: float between 0.5 and 1.0 (floor at 0.5, cap at 1.0)

Also add a query length cap to prevent abuse:
```typescript
if (query.length > 1000) {
  return new Response(
    JSON.stringify({ error: "Query too long" }),
    { status: 400, headers: { "Content-Type": "application/json" } }
  );
}
```

Add this after the existing `if (!query || typeof query !== "string")` check.

This prevents callers from requesting unbounded result sets or setting thresholds so low that every memory matches.
  </action>
  <verify>
Read search/index.ts and confirm:
- `match_count` clamped with `Math.min(..., 20)` and `Math.max(..., 1)`
- `match_threshold` clamped with `Math.max(..., 0.5)`
- Query length check present (max 1000 chars)
- Clamped values used in the RPC call, not raw values
  </verify>
  <done>Search function enforces match_count between 1-20, match_threshold between 0.5-1.0, and query length max 1000 chars.</done>
</task>

</tasks>

<verification>
1. Read embed/index.ts — content comes from DB SELECT, not client payload
2. Read search/index.ts — match_count clamped to [1, 20], match_threshold clamped to [0.5, 1.0]
3. No unclamped user input reaches database queries in either function
</verification>

<success_criteria>
- Embed function queries global_memory by ID and uses DB content for embedding
- Search function enforces match_count <= 20 and match_threshold >= 0.5
- Query length capped at 1000 characters
</success_criteria>

<output>
After completion, create `.planning/phases/23-edge-function-security/23-02-SUMMARY.md`
</output>
