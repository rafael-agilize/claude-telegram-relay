---
phase: 25-intent-validation-input-hardening
plan: 02
type: execute
wave: 2
depends_on: [25-01]
files_modified: [src/relay.ts]
autonomous: true

must_haves:
  truths:
    - "/soul command rejects content over 2000 characters with user feedback message"
    - "Memory insertion evicts oldest entries when at capacity (100 facts, 50 goals)"
    - "sanitizeFilename strips null bytes and replaces non-allowlist characters with underscore"
    - "Lock file acquisition fails immediately on 'wx' error without fallback overwrite"
  artifacts:
    - path: "src/relay.ts"
      provides: "Hardened input validation, memory caps, filename sanitization, atomic lock"
      contains: "MAX_FACTS"
  key_links:
    - from: "/soul command handler"
      to: "setSoul()"
      via: "length check before calling setSoul"
      pattern: "args\\.length.*>.*2000"
    - from: "insertMemory()"
      to: "evictOldestMemory()"
      via: "count check before insert"
      pattern: "MAX_FACTS|MAX_GOALS"
---

<objective>
Harden relay inputs: cap /soul content, enforce memory entry limits with eviction, fix filename sanitization, and make lock file truly atomic.

Purpose: Prevent memory abuse (unbounded growth), path traversal via crafted filenames, and race conditions in lock acquisition.
Output: Updated relay.ts with input caps, memory eviction, allowlist filename sanitization, and atomic-only lock file.
</objective>

<execution_context>
@/Users/roviana/.claude/get-shit-done/workflows/execute-plan.md
@/Users/roviana/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/relay.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Cap /soul content, enforce memory limits with eviction, and fix sanitizeFilename</name>
  <files>src/relay.ts</files>
  <action>
Three changes in `src/relay.ts`:

**1. /soul content cap (INPUT-01)** — In the `/soul` command handler (line ~3139, the "Default: set soul personality" block):

Before `const success = await setSoul(args);`, add a length check:
```typescript
if (args.length > 2000) {
  await ctx.reply(`Soul text too long (${args.length} chars). Maximum is 2000 characters.`);
  return;
}
```

**2. Memory entry count caps with eviction (INPUT-02)** — Add constants and eviction helper near `insertMemory()` (around line 357):

Add constants before insertMemory:
```typescript
const MAX_FACTS = 100;
const MAX_GOALS = 50;
```

Add eviction helper after insertMemory (around line 392):
```typescript
async function evictOldestMemory(type: string, maxCount: number): Promise<void> {
  if (!supabase) return;
  try {
    const { count } = await supabase
      .from("global_memory")
      .select("id", { count: "exact", head: true })
      .eq("type", type);

    if (count !== null && count >= maxCount) {
      const excess = count - maxCount + 1; // Make room for new entry
      const { data: oldest } = await supabase
        .from("global_memory")
        .select("id")
        .eq("type", type)
        .order("created_at", { ascending: true })
        .limit(excess);

      if (oldest && oldest.length > 0) {
        const ids = oldest.map((r: { id: string }) => r.id);
        await supabase.from("global_memory").delete().in("id", ids);
        console.log(`[Memory] Evicted ${ids.length} oldest ${type}(s) to stay under ${maxCount} cap`);
      }
    }
  } catch (e) {
    console.error(`evictOldestMemory error (${type}):`, e);
  }
}
```

Modify `insertMemory()` to call eviction before insert:
- After the `if (!supabase) return false;` check, add:
```typescript
const typeLimit = type === "fact" ? MAX_FACTS : type === "goal" ? MAX_GOALS : null;
if (typeLimit !== null) {
  await evictOldestMemory(type, typeLimit);
}
```

**3. Allowlist filename sanitization (INPUT-03)** — Replace the `sanitizeFilename` function (line ~65):

Replace:
```typescript
function sanitizeFilename(name: string): string {
  return name.replace(/[\/\\]/g, "_").replace(/\.\./g, "_");
}
```

With:
```typescript
function sanitizeFilename(name: string): string {
  // Strip null bytes first
  const clean = name.replace(/\0/g, "");
  // Allowlist: only keep alphanumeric, dots, hyphens, underscores
  return clean.replace(/[^a-zA-Z0-9._-]/g, "_");
}
```

This is stricter: instead of blacklisting `/ \ ..`, it allowlists only safe characters. Null bytes are stripped explicitly before the regex.
  </action>
  <verify>
1. Search for `args.length > 2000` in the /soul handler
2. Search for `MAX_FACTS` and `MAX_GOALS` constants
3. Search for `evictOldestMemory` function
4. Verify `insertMemory` calls `evictOldestMemory` before insert
5. Verify `sanitizeFilename` uses allowlist regex `[^a-zA-Z0-9._-]` and strips `\0`
  </verify>
  <done>/soul rejects >2000 chars with user feedback. Memory capped at 100 facts + 50 goals with oldest-first eviction. sanitizeFilename uses allowlist regex and strips null bytes.</done>
</task>

<task type="auto">
  <name>Task 2: Make lock file acquisition atomic without fallback overwrite</name>
  <files>src/relay.ts</files>
  <action>
Fix the `acquireLock()` function (line ~2420) to remove the non-atomic fallback path.

Current code has a race condition: if `open(LOCK_FILE, "wx")` fails (file exists between stale check and open), it falls back to `writeFile(LOCK_FILE, ...)` which is a non-atomic overwrite.

Replace the lock acquisition logic inside the try block (after the stale lock removal):

```typescript
async function acquireLock(): Promise<boolean> {
  try {
    const existingLock = await readFile(LOCK_FILE, "utf-8").catch(() => null);

    if (existingLock) {
      const pid = parseInt(existingLock);
      try {
        process.kill(pid, 0);
        console.log(`Another instance running (PID: ${pid})`);
        return false;
      } catch {
        console.log("Stale lock found, removing...");
        await unlink(LOCK_FILE).catch(() => {});
      }
    }

    // Atomic exclusive create — fails if another process created it between our check and here
    const fd = await open(LOCK_FILE, "wx");
    await fd.writeFile(process.pid.toString());
    await fd.close();
    return true;
  } catch (error) {
    // "wx" flag throws if file exists — another instance won the race
    console.error("Could not acquire lock — another instance may have started:", (error as Error).message);
    return false;
  }
}
```

Key changes:
1. After detecting stale lock, **delete** the lock file with `unlink()` before attempting `wx` open (instead of relying on fallback).
2. Remove the `const fd = await open(...).catch(() => null)` + fallback `writeFile` pattern. Instead, let `open("wx")` throw on failure.
3. The outer catch handles the case where another process created the file between our unlink and open — returns `false` (correct behavior).
  </action>
  <verify>
1. Verify `acquireLock` does NOT contain `writeFile(LOCK_FILE` (the non-atomic fallback is removed)
2. Verify `acquireLock` uses `await open(LOCK_FILE, "wx")` without `.catch(() => null)`
3. Verify stale lock path calls `unlink(LOCK_FILE)` before attempting wx open
  </verify>
  <done>Lock file uses atomic-only "wx" open. No fallback non-atomic overwrite path. Race condition between instances results in clean failure (returns false).</done>
</task>

</tasks>

<verification>
1. `/soul` handler rejects text > 2000 chars with user-facing message
2. `MAX_FACTS = 100` and `MAX_GOALS = 50` constants exist
3. `evictOldestMemory` function exists and is called from `insertMemory`
4. `sanitizeFilename` uses `[^a-zA-Z0-9._-]` allowlist and `\0` stripping
5. `acquireLock` has no `writeFile(LOCK_FILE` fallback — only atomic `wx` open
6. TypeScript compiles: `bun build src/relay.ts --no-bundle`
</verification>

<success_criteria>
- `/soul` with 2001+ char text returns rejection message to user
- Inserting 101st fact evicts the oldest fact before insert
- Inserting 51st goal evicts the oldest goal before insert
- Filename with unicode/special chars is sanitized to underscores
- Filename with null bytes has them stripped
- Lock acquisition fails cleanly when another instance races
</success_criteria>

<output>
After completion, create `.planning/phases/25-intent-validation-input-hardening/25-02-SUMMARY.md`
</output>
