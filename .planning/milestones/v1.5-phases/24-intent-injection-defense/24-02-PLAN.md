---
phase: 24-intent-injection-defense
plan: 02
type: execute
wave: 2
depends_on: ["24-01"]
files_modified: [src/relay.ts]
autonomous: true

must_haves:
  truths:
    - "Agent-created cron jobs via [CRON:] intent are inserted as disabled (enabled=false)"
    - "User receives a Telegram message with inline approve/reject buttons when agent creates a cron job"
    - "Pressing Approve activates the cron job (enabled=true) and updates the message"
    - "Pressing Reject deletes the cron job and updates the message"
    - "User-created cron jobs via /cron add remain immediately active (no confirmation needed)"
    - "File-sourced cron jobs from HEARTBEAT.md remain immediately active (no confirmation needed)"
  artifacts:
    - path: "src/relay.ts"
      provides: "Cron confirmation flow with InlineKeyboard callbacks"
      contains: "InlineKeyboard"
  key_links:
    - from: "processIntents() CRON block"
      to: "createCronJob()"
      via: "enabled=false for agent source"
      pattern: "enabled.*false"
    - from: "processIntents() CRON block"
      to: "bot.api.sendMessage"
      via: "InlineKeyboard with approve/reject"
      pattern: "InlineKeyboard"
    - from: "bot.callbackQuery()"
      to: "cron_jobs table"
      via: "enable or delete based on button pressed"
      pattern: "cron_approve|cron_reject"
---

<objective>
Add user confirmation flow for agent-created cron jobs: agent [CRON:] intents create disabled jobs and send an approval message with inline buttons.

Purpose: Prevent autonomous cron job proliferation. The agent can propose cron jobs but cannot activate them without human approval. This closes the prompt injection vector where automated contexts could create self-replicating scheduled tasks.
Output: Confirmation flow with InlineKeyboard approve/reject buttons and callback handler.
</objective>

<execution_context>
@/Users/roviana/.claude/get-shit-done/workflows/execute-plan.md
@/Users/roviana/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/24-intent-injection-defense/24-01-SUMMARY.md
@src/relay.ts (lines 2167-2195 ‚Äî CRON intent processing block)
@src/relay.ts (lines 1038-1082 ‚Äî createCronJob function)
@src/relay.ts (lines 13 ‚Äî grammy imports)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create disabled cron jobs for agent source and send confirmation message</name>
  <files>src/relay.ts</files>
  <action>
1. **Update Grammy imports** (line 13):
   Change: `import { Bot, Context, InputFile } from "grammy";`
   To: `import { Bot, Context, InputFile, InlineKeyboard } from "grammy";`

2. **Modify the CRON intent block in processIntents()** (around line 2167-2195):
   Currently, agent-created cron jobs call `createCronJob()` which inserts with `enabled: true`. Change the flow so that when `source === 'agent'` (which is always the case inside processIntents), the job is created as disabled and a confirmation message is sent.

   Replace the CRON intent processing block with:
   ```typescript
   // [CRON: schedule | prompt] ‚Äî agent self-scheduling (requires approval)
   const cronMatches = response.matchAll(/\[CRON:\s*(.+?)\s*\|\s*(.+?)\]/gi);
   for (const match of cronMatches) {
     if (!allowed.has('CRON')) {
       console.warn(`[Intents] Blocked CRON intent in '${context}' context: ${match[1].trim().substring(0, 50)}`);
     } else {
       const schedule = match[1].trim();
       const prompt = match[2].trim();

       if (schedule.length > 0 && prompt.length > 0 && prompt.length <= 500) {
         const scheduleType = detectScheduleType(schedule);
         if (scheduleType) {
           const name = prompt.length <= 50 ? prompt : prompt.substring(0, 47) + "...";
           // Agent-created jobs start DISABLED ‚Äî require user approval
           const job = await createCronJob(name, schedule, scheduleType, prompt, threadDbId || undefined, "agent", false);
           if (job) {
             console.log(`[Agent] Created pending cron job: "${name}" (${schedule}) ‚Äî awaiting approval`);
             await logEventV2("cron_created", `Agent created cron job (pending approval): ${name}`, {
               job_id: job.id,
               schedule,
               schedule_type: scheduleType,
               prompt: prompt.substring(0, 100),
               source: "agent",
               pending_approval: true,
             }, threadDbId);
             // Send confirmation message to user
             await sendCronApprovalMessage(job);
           }
         } else {
           console.warn(`[Agent] Invalid schedule in CRON intent: "${schedule}"`);
         }
       } else {
         console.warn(`[Agent] Rejected CRON intent: schedule="${schedule}" prompt length=${prompt.length}`);
       }
     }
     clean = clean.replace(match[0], "");
   }
   ```

3. **Add optional `initialEnabled` parameter to createCronJob()** (around line 1038):
   Change the signature from:
   ```typescript
   async function createCronJob(
     name: string,
     schedule: string,
     scheduleType: 'cron' | 'interval' | 'once',
     prompt: string,
     targetThreadId?: string,
     source: 'user' | 'agent' | 'file' = 'user'
   ): Promise<CronJob | null> {
   ```
   To:
   ```typescript
   async function createCronJob(
     name: string,
     schedule: string,
     scheduleType: 'cron' | 'interval' | 'once',
     prompt: string,
     targetThreadId?: string,
     source: 'user' | 'agent' | 'file' = 'user',
     initialEnabled: boolean = true
   ): Promise<CronJob | null> {
   ```

   Then change the insert call to use `initialEnabled` instead of hardcoded `true`:
   ```typescript
   enabled: initialEnabled,
   ```

   Also, only compute next_run_at when the job is enabled:
   ```typescript
   if (initialEnabled) {
     const nextRun = computeNextRun(job);
     if (nextRun) {
       await supabase.from("cron_jobs").update({ next_run_at: nextRun }).eq("id", job.id);
     }
   }
   ```

4. **Create the sendCronApprovalMessage() function** (near the cron management section, around line 1082):
   ```typescript
   async function sendCronApprovalMessage(job: CronJob): Promise<void> {
     try {
       const keyboard = new InlineKeyboard()
         .text("‚úÖ Approve", `cron_approve:${job.id}`)
         .text("‚ùå Reject", `cron_reject:${job.id}`);

       const message = [
         `ü§ñ *Agent wants to create a cron job:*`,
         ``,
         `*Name:* ${escapeMarkdown(job.name)}`,
         `*Schedule:* \`${job.schedule}\` (${job.schedule_type})`,
         `*Prompt:* ${escapeMarkdown(job.prompt.substring(0, 200))}`,
         ``,
         `_Job is paused until you approve._`,
       ].join("\n");

       // Send to authorized user's DM
       await bot.api.sendMessage(AUTHORIZED_USER_ID, message, {
         parse_mode: "Markdown",
         reply_markup: keyboard,
       });
     } catch (err: any) {
       console.error(`[CronApproval] Failed to send approval message for job ${job.id}:`, err.message);
     }
   }
   ```

   Note: `escapeMarkdown()` may or may not exist. Check for it in relay.ts. If it doesn't exist, add a simple helper:
   ```typescript
   function escapeMarkdown(text: string): string {
     return text.replace(/[_*[\]()~`>#+\-=|{}.!]/g, '\\$&');
   }
   ```
   If it already exists, reuse it.

   Note: `AUTHORIZED_USER_ID` ‚Äî check how the relay references the authorized Telegram user ID. It's likely `TELEGRAM_USER_ID` or similar env var stored as a constant. Use whatever constant the codebase already uses. The approval message goes directly to the user's DM regardless of which thread the intent was triggered from.
  </action>
  <verify>
Grep for "InlineKeyboard" in relay.ts ‚Äî should find the import and the keyboard construction.
Grep for "cron_approve" in relay.ts ‚Äî should find the callback data in the keyboard.
Grep for "initialEnabled" in relay.ts ‚Äî should find the parameter in createCronJob.
Grep for "sendCronApprovalMessage" ‚Äî should find the function definition and the call from processIntents.
Confirm createCronJob is called with `false` as last argument from the CRON intent block.
  </verify>
  <done>Agent-created cron jobs are inserted as disabled. A Telegram message with approve/reject inline buttons is sent to the authorized user.</done>
</task>

<task type="auto">
  <name>Task 2: Add callback query handler for approve/reject buttons</name>
  <files>src/relay.ts</files>
  <action>
Add a callback query handler for the inline keyboard buttons. Place it near the other bot handlers (before `bot.start()`).

1. **Register the callback query handler** (near the message handlers section, after the document handler):
   ```typescript
   // Cron job approval/rejection via inline keyboard
   bot.on("callback_query:data", async (ctx) => {
     const data = ctx.callbackQuery.data;

     // Only handle cron approval callbacks
     if (!data.startsWith("cron_approve:") && !data.startsWith("cron_reject:")) {
       return;
     }

     const [action, jobId] = data.split(":");
     if (!jobId) {
       await ctx.answerCallbackQuery({ text: "Invalid callback data" });
       return;
     }

     if (action === "cron_approve") {
       // Enable the job
       if (supabase) {
         const { error } = await supabase
           .from("cron_jobs")
           .update({ enabled: true })
           .eq("id", jobId);

         if (error) {
           console.error(`[CronApproval] Failed to approve job ${jobId}:`, error);
           await ctx.answerCallbackQuery({ text: "Failed to approve job" });
           return;
         }

         // Compute and set next_run_at now that job is enabled
         const { data: jobData } = await supabase
           .from("cron_jobs")
           .select("*")
           .eq("id", jobId)
           .single();

         if (jobData) {
           const nextRun = computeNextRun(jobData as CronJob);
           if (nextRun) {
             await supabase.from("cron_jobs").update({ next_run_at: nextRun }).eq("id", jobId);
           }
         }

         await logEventV2("cron_approved", `User approved cron job: ${jobId}`, { job_id: jobId });
         console.log(`[CronApproval] Job ${jobId} approved by user`);

         // Update the message to show approved state
         await ctx.editMessageText(`‚úÖ *Cron job approved and activated!*\n\n_Job ID: ${jobId}_`, {
           parse_mode: "Markdown",
         });
         await ctx.answerCallbackQuery({ text: "Cron job approved!" });
       }
     } else if (action === "cron_reject") {
       // Delete the job
       if (supabase) {
         const { error } = await supabase
           .from("cron_jobs")
           .delete()
           .eq("id", jobId);

         if (error) {
           console.error(`[CronApproval] Failed to reject job ${jobId}:`, error);
           await ctx.answerCallbackQuery({ text: "Failed to reject job" });
           return;
         }

         await logEventV2("cron_rejected", `User rejected cron job: ${jobId}`, { job_id: jobId });
         console.log(`[CronApproval] Job ${jobId} rejected by user`);

         // Update the message to show rejected state
         await ctx.editMessageText(`‚ùå *Cron job rejected and deleted.*\n\n_Job ID: ${jobId}_`, {
           parse_mode: "Markdown",
         });
         await ctx.answerCallbackQuery({ text: "Cron job rejected" });
       }
     }
   });
   ```

2. **Verify the handler is registered BEFORE `bot.start()`** ‚Äî Grammy requires all handlers to be registered before starting the bot.

3. **Important:** The callback query handler does NOT need auth middleware because:
   - The approval message is only sent to AUTHORIZED_USER_ID (the DM)
   - Telegram callback queries can only come from the user who sees the inline keyboard
   - But as a safety measure, add a user ID check at the top:
   ```typescript
   // Security: only authorized user can approve/reject
   if (ctx.callbackQuery.from.id.toString() !== AUTHORIZED_USER_ID.toString()) {
     await ctx.answerCallbackQuery({ text: "Unauthorized" });
     return;
   }
   ```
   Find the correct variable name for the authorized user ID by searching relay.ts for TELEGRAM_USER_ID or similar pattern. Use that exact variable.
  </action>
  <verify>
Grep for "callback_query:data" in relay.ts ‚Äî should find the handler registration.
Grep for "cron_approved" in relay.ts ‚Äî should find the log event.
Grep for "cron_rejected" in relay.ts ‚Äî should find the log event.
Grep for "editMessageText" in relay.ts ‚Äî should find 2 occurrences (approve and reject).
Grep for "answerCallbackQuery" in relay.ts ‚Äî should find multiple occurrences.
Confirm the handler is placed before `bot.start()`.
  </verify>
  <done>Callback query handler processes approve/reject button presses. Approve enables the job and sets next_run_at. Reject deletes the job. Both update the inline message to reflect the action taken. Auth check ensures only the authorized user can interact with the buttons.</done>
</task>

</tasks>

<verification>
1. `grep -n "InlineKeyboard" src/relay.ts` ‚Äî import and usage present
2. `grep -n "callback_query" src/relay.ts` ‚Äî handler registered
3. `grep -n "initialEnabled" src/relay.ts` ‚Äî createCronJob accepts the parameter
4. `grep -n "cron_approve\|cron_reject\|cron_approved\|cron_rejected" src/relay.ts` ‚Äî callback data and log events
5. `grep -n "sendCronApprovalMessage" src/relay.ts` ‚Äî function defined and called
6. Verify that `/cron add` command still creates jobs with `enabled: true` (unchanged ‚Äî it doesn't pass `false`)
7. Verify that `syncCronJobsFromFile()` still creates jobs with `enabled: true` (unchanged ‚Äî it doesn't pass `false`)
8. `bun run start` succeeds without TypeScript errors
</verification>

<success_criteria>
- Agent [CRON:] intents create disabled jobs (enabled=false)
- User/file cron jobs remain immediately active (enabled=true, no change)
- Approval message sent to authorized user with approve/reject inline buttons
- Approve button enables job, computes next_run_at, updates message
- Reject button deletes job, updates message
- Callback handler has auth check for authorized user
- All actions logged to logs_v2
- No TypeScript compilation errors
</success_criteria>

<output>
After completion, create `.planning/phases/24-intent-injection-defense/24-02-SUMMARY.md`
</output>
